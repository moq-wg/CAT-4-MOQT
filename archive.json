{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-06T01:03:35.153934+00:00",
  "repo": "wilaw/CAT-4-MOQT",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOODoKls6uBWw2",
      "title": "Token renewal",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/1",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I volunteer to write some text to explain how the token renewal can be implemented.",
      "createdAt": "2025-03-14T08:40:21Z",
      "updatedAt": "2025-03-14T08:40:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOODoKls6uBiHC",
      "title": "No token at connection but token for actions",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/2",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "One of the limitations of having a unique global token to rule all future actions is that the token's expiration time must be long to anticipate the actions in the future. It can be preferrable to have tokens with short expiration time for specific action, but it contradicts the global unique token.\n\nI would like to define an alternative workflow, where the token at WebTransport is optional, but a token must be carried in the actions (SUBSCRIBE, FETCH, ...) as authentication-parameter.",
      "createdAt": "2025-03-14T08:59:41Z",
      "updatedAt": "2025-03-14T09:15:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "Some ideas on how to achieve this:\n1. You give the player two tokens - one for the connection and another for actions. \n2. In the moqt claim, we add an action for \"CONNECT\". We then rely on future implementation of composite claims so that each  moqt action can be combined with an existing CAT claim such as time, geo etc. ",
          "createdAt": "2025-03-14T09:15:37Z",
          "updatedAt": "2025-03-14T09:15:37Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOODoKls6uEJaW",
      "title": "does the expiration of a token also apply to the ongoing SUBSCRIBE?",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/3",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Let's say an end-user connects to a Relay with a token that expires in 60 minutes. What I understand is that, if the user emits a SUBSCRIBE 65 minutes later, then the Relay will reject the request. However, if the user sends a SUBSCRIBE to a track immediately after the connection, it got the stream. 60 minutes later, should the Relay abruptly stop the track delivery? It would require the Relay to keep trace of the finishing time of each ongoing track. ",
      "createdAt": "2025-03-14T14:02:01Z",
      "updatedAt": "2025-03-18T13:50:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "As currently defined, the expiry time applies only to the initial connection. This means that if the client connects  to the relay with a 60min token at 10:00, then the client can do all the subscribing that it wants, but at 11:00, the relay will terminate the connection, which will effectively end all tracks being published and or subscribed in that session. ",
          "createdAt": "2025-03-18T13:50:51Z",
          "updatedAt": "2025-03-18T13:50:51Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOODoKls6uFN6-",
      "title": "token revocation",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/4",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It can happen that the content distributor would like to revoke a token. It is an offline action, which can impact the ongoing sessions.\n\nIf the full token is revoked, then it should mean closure of the WebTransport or MoQ connection. This can happen when the content distributor has identified the end-user as a leak.\n\nIf only some MoQT actions are revoked, then the related actions should be stopped: for example the Relay should stop the subscription to a track whose grant has been revoked. The use cases are less clear, but, I can think of a countermeasure where an identified leak can no longer get the top video profile but can still access a subset of degraded tracks.",
      "createdAt": "2025-03-14T15:49:20Z",
      "updatedAt": "2025-03-14T15:49:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOODoKls6uY6_m",
      "title": "Add a new CONNECTION action to the moq claim",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/5",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Right now, we assume the existing CAT claims (exp, catu, geohash etc) apply to the initial connection via either Web transport or native QUIC.\n\nThis relationship becomes brittle if we introduce COMPOSITE claims, in which there may be multiple 'exp' claims bound to Actions, while some remain unbound and are assumed to apply to the connection.\n\nAn improvement here would be to make 2 changes\n1. Add in CONNECTION as a new ACTION type.\n2. Allow claims to be composite. \n\nFor example the following combination lets you connect from anywhere before a certain time,  but only publish from Germany with a prefix match of example.com\n\nMOQ CONNECTION allowed AND exp  = 1742229697 \nMOQ PUBLISH (prefix match 'example.com') AND catgeoiso3166 = DE",
      "createdAt": "2025-03-17T16:47:05Z",
      "updatedAt": "2025-03-18T13:23:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "One problem I discovered with this approach is that you cannot repeat a claim in a CWT token. So you cannot have two expiry or geo claims, one for connect, another for publish. ",
          "createdAt": "2025-03-18T13:23:32Z",
          "updatedAt": "2025-03-18T13:23:32Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOODoKls6vEm70",
      "title": "Add TRACK_STATUS_REQUEST action",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/6",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/moq-wg/moq-transport/issues/720\n\nAlternately it could share SUBSCRIBE, or we could have a blanket action like CONSUME which would cover SUBSCRIBE, FETCH and TRACK_STATUS_REQUEST.",
      "createdAt": "2025-03-21T04:20:12Z",
      "updatedAt": "2025-03-21T23:56:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "Adding a TRACk_STATUS_REQUEST action is an easy move.\n\nI really like the idea of CONSUME. It is a logical aggregation which is likely to be highly common and it reduces the need to define a moqt claim for each child action. We should add SUBSCRIBE_ANNOUNCES to that pool. \n\nShould we have a counterpoint PRODUCE, which would aggregate ANNOUNCE and PUBLISH? ",
          "createdAt": "2025-03-21T10:04:34Z",
          "updatedAt": "2025-03-21T10:04:34Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Maybe three actions: PRODUCE (Publish, Announce), CONSUME (Track Status Request, Subscribe, Fetch), DISCOVER (Subscribe Announces)?",
          "createdAt": "2025-03-21T23:56:44Z",
          "updatedAt": "2025-03-21T23:56:44Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOODoKls6vyvuO",
      "title": "When are claims evaluated in long duration sessions?",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/7",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "CAT claims are written assuming a request, which occurs at a single point in time. However MOQT has actions which can persist over the life of the session, which may last a long time. This issue raises the need to evaluate the claims within CAT and define how they might be applied to long running sessions. \n\nFor example, if a claim binds a connection to an IP address and that IP address later changes while the session is still active due to QUIC connection migration, should the connection be dropped? \n\nAt what interval is the server required to evaluate the IP address - with each incoming QUIC frame, or MOQT object or some other interval or event? ",
      "createdAt": "2025-03-26T11:54:34Z",
      "updatedAt": "2025-03-26T11:54:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOODoKls6zTjzr",
      "title": "A wrapper for composite claims",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/8",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "How do we bind ACTIONs to differentiated base CAT claims? For example , you can connect and SUBSCRIBE from anywhere in Europe after 4pm  but you can only PUBLISH after 6pm in Germany?\n\nOne solution would be to define a wrapper to hold different CAT tokens and allow them to be assigned to different ACTIONS. \nThe wrapper needs to be signed to be prevent tampering, but not encrypted, since the core CAT tokens it includes are already encrypted. \n\n![Image](https://github.com/user-attachments/assets/284afdbd-c4e7-4eda-bf45-e2c9f068bf68)\n",
      "createdAt": "2025-04-21T11:48:21Z",
      "updatedAt": "2025-04-21T11:48:21Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOODoKls6UzS5E",
      "title": "First round of edits to fill out the definition of the claim.",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/9",
      "state": "OPEN",
      "author": "alficles",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-02T22:30:52Z",
      "updatedAt": "2025-05-05T19:20:07Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "7c068e5ecc179dc39a8fb306278577da3c7dd813",
      "headRepository": "alficles/CAT-4-MOQT",
      "headRefName": "main",
      "headRefOid": "60550df5b17fb275074f3e5d0abddcba00698e55",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOODoKls6nrit7",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "This is a great start Chris - thanks for kicking it off. ",
          "createdAt": "2025-05-03T10:51:09Z",
          "updatedAt": "2025-05-03T11:27:21Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "The actions in MOQT are not extensible and are not defined in a registry,. They are defined by a particular version of the specification .  I think we can avoid the registry table and instead indicate that if anyone extends this specification to match a future version of MOQT, that they should provide a new action and its key.  \r\n\r\nThe actions we need to support with the current draft of MOQT are\r\n\r\nCONNECT\r\nANNOUNCE\r\nSUBSCRIBE_ANNOUNCES\r\nSUBSCRIBE\r\nFETCH\r\nPUBLISH (not yet defined but likely will be). \r\nTRACK_STATUS_REQUEST\r\n",
              "createdAt": "2025-05-03T10:51:09Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 91,
              "body": "For simplicity we should exclude SHA* match types and just allow exact-match, prefix-match, suffix-match and contains-match. ",
              "createdAt": "2025-05-03T10:53:13Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 96,
              "body": "Namespace is always a byte array, as is Name.  Even though URLs are used for clarity in most examples, in practice a streaming format would need to specify how these are serialized i.e UTF-8. ",
              "createdAt": "2025-05-03T10:55:46Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 107,
              "body": "This needs to be a byte match, not a string match. ",
              "createdAt": "2025-05-03T10:56:23Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 108,
              "body": "Name should also be a byte match",
              "createdAt": "2025-05-03T10:56:53Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 93,
              "body": "in MOQT a Track Namespace is an ordered N-tuple of bytes where N can be between 1 and 32. Track Name is a sequence of bytes that identifies an individual track within the namespace.\r\nSee https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#name-track-naming\r\n\r\nFor the token, I don't think we need to specify a N-32 tuple for the match. We can indicate that the tuples should be concatenated and then compared. Language might be `Namespaces are compared using lexicographic ordering on their byte-wise representations, where each namespace is treated as a byte string formed by concatenating its constituent bytes in order.\r\n`",
              "createdAt": "2025-05-03T11:09:45Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 198,
              "body": "Yes, this is an important point. I will raise for discussion at Stockholm interim. Some ideas\r\n1. We leave the interval up to the enforcer. Some might find it cheap to evaluate with each object sent, others at a time interval. This will lead to poor interop so I don't like this approach. \r\n2. We can set upper bounds on the maximum time at which each claim MUST be checked. This may be per object sent, 1s wallclock time, 10s, 60s etc. This may be set by this RFC, or it may be a part of the claim payload?",
              "createdAt": "2025-05-03T11:17:34Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 229,
              "body": "As mentioned earlier, actions are defined by MOQT RFC and are not extensible. We can require that new specifications include and action and a key value when extending cat-4-moqt. \r\n\r\nReusing message id is not an option. The message id mutates with each message sent so it would not work for the repeated use of tokens. \r\n> The client's Request ID starts at 0 and are even and the server's Request ID starts at 1 and are odd. The Request ID increments by 2 with ANNOUNCE, FETCH, SUBSCRIBE, SUBSCRIBE_ANNOUNCES or TRACK_STATUS request.",
              "createdAt": "2025-05-03T11:22:54Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 181,
              "body": "Would be nice to add an additional example showing a complete set of composite claims, using expiry, not before, cwt ID, geo, etc. ",
              "createdAt": "2025-05-03T11:26:44Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nvIH2",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T08:36:19Z",
          "updatedAt": "2025-05-05T08:36:19Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Should we consider contains-match? It could be heavy in terms of processing at the edge. We may also need to explain how to compute this match based on the N (1..32) set of bytes. For example, do we allow */foo/*/bar/*?\r\n\r\nSimilarly, is there a use-case for suffix-match? \r\n\r\nIn MOQT, the announces are based on Prefix only, aren't they?   ",
              "createdAt": "2025-05-05T08:36:19Z",
              "updatedAt": "2025-05-05T08:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nvIdz",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T08:37:00Z",
          "updatedAt": "2025-05-05T08:37:00Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Same as previous comment. \r\nWe could restrict the operation to the Prefix-match, which is the one defined in MOQT.",
              "createdAt": "2025-05-05T08:37:00Z",
              "updatedAt": "2025-05-05T08:37:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nwIev",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T10:37:46Z",
          "updatedAt": "2025-05-05T10:37:47Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "We have a bigger problem in that I believe the match functions operate on strings only, not on byte arrays",
              "createdAt": "2025-05-05T10:37:46Z",
              "updatedAt": "2025-05-05T10:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nyVmt",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T14:19:33Z",
          "updatedAt": "2025-05-05T14:19:33Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "The need for re-evaluation is indeed a point (also related to #3 and #7).\r\n\r\nYour idea 1 does not bring any guarantee of content protection, which is indeed not ideal.\r\nYour idea 2 may potentially be exploited. A pirates who knows when the server will check the IP address to verify some claims can migrate IP only for one object and continue streaming the rest of the time.\r\n\r\nA third idea would be to verify the claims when one of the characteristics related to the claims changes mid-stream. For example a HTTP/3 hook when the IP address changes at QUIC level would force a re-validation of the claims related to catnip and geo claims. The server would need to store, for every connection, all the characteristics that have been used to validate the claim at the latest verification. The advantage is that, for a stable connection, the server would never re-process the token,",
              "createdAt": "2025-05-05T14:19:33Z",
              "updatedAt": "2025-05-05T14:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzLOb",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:29:13Z",
          "updatedAt": "2025-05-05T15:29:13Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "There's not a ton of point excluding the SHA options because making them optional for the receiver (that is, not a point on which you can guarantee interoperability) already effectively does it. For contains, the maximum cost is a single scan of the string, which is guaranteed to be relatively short.",
              "createdAt": "2025-05-05T15:29:13Z",
              "updatedAt": "2025-05-05T15:29:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzO6X",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:35:06Z",
          "updatedAt": "2025-05-05T15:35:06Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "As I noodle on this, I'm thinking that we might handle token evaluation the same way you handle caching. The token could tell you how long you're allowed to cache the results and if you ask the relay to revalidate more frequently than it is willing, it stops serving your content. In practice, implementers would pick a minimum and reject tokens that ask for too frequent revalidation.\r\n\r\nConsidering that in the ABR world, people can and do re-evaluate the token, including the signature (which doesn't need re-checking for MOQT), every single fragment, I suspect that even extremely frequent re-evaluation isn't going to break anything.",
              "createdAt": "2025-05-05T15:35:06Z",
              "updatedAt": "2025-05-05T15:35:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzU7Z",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:43:27Z",
          "updatedAt": "2025-05-05T15:43:27Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I should have said Message Type IDs here. See Figure 3 in Section 8 of draft-ietf-moq-transport. So, for example, ANNOUNCE is 0x6, FETCH is 0x16, SUBSCRIBE is 0x3, SUBSCRIBE_ANNOUNCES is 0x11, and TRACK_STATUS is 0xE. The advantage is that you don't wind up using different numbers to describe the same concept and it means you don't have to define a list in the auth token. It also makes it effectively automatically extensible if someone defines a new frame in the future.\r\n\r\nThe main downside is that it allows you to express the idea of having the auth token apply to message types that might not make sense, like \"FETCH_ERROR\" or \"MAX_REQUEST_ID\". This could lead to confusion, or in the worst case, a naive implementation causing real problems for themselves.",
              "createdAt": "2025-05-05T15:43:27Z",
              "updatedAt": "2025-05-05T15:43:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzZiM",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:50:55Z",
          "updatedAt": "2025-05-05T15:50:55Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I think I'm going to have to re-define the match object, though, which is mildly annoying. I'd be fine if I had defined the input to match in CAT as a byte array, but alas, this is the kind of minor incompatibility I was worried about. The devil is always in the details. :)\r\n\r\nThere genuinely is a difference here, because the byte array is allowed to contain invalid unicode characters. And if someone implemented this with a library that handles unicode, concatenating a namespace with invalid unicode with a track name that you incorrectly assume is unicode can result in misinterpreting the first byte, which in the context of an auth token can result in incorrect access.",
              "createdAt": "2025-05-05T15:50:55Z",
              "updatedAt": "2025-05-05T15:50:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6n1mZw",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T19:20:06Z",
          "updatedAt": "2025-05-05T19:20:07Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I like idea of reusing the message type as its naturally extensible without having to rev this draft.  There is no danger in having the token apply to message types that don't carry auth precisely because the serialization of those message types doesn't provide for transmission of the auth token. \r\n\r\nOne problem is that if we want to protect CONNECT, it is not a message. We could use the special type of 0x0 for this, but now we have a blend of custom defined types and MOQT message types. \r\n\r\nAnother problem is that MOQT might reassign message types between versions? ",
              "createdAt": "2025-05-05T19:20:06Z",
              "updatedAt": "2025-05-05T19:25:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOODoKls6U6F0O",
      "title": "Update draft-law-moq-cat4moqt.md",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/10",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Polishing the Introduction to refine the concept of \"trusted MoQ distribution network\"",
      "createdAt": "2025-05-05T09:27:42Z",
      "updatedAt": "2025-05-05T09:27:43Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "8687628347be73234f01fdf16e06ff5bcbadce70",
      "headRepository": "gwendalsimon/CAT-4-MOQT",
      "headRefName": "patch-1",
      "headRefOid": "c241235bd5a7c73c05b5bd2390b656b6b46bb0b2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}