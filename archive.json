{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-20T01:17:34.256364+00:00",
  "repo": "wilaw/CAT-4-MOQT",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOODoKls6uBWw2",
      "title": "Token renewal",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/1",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I volunteer to write some text to explain how the token renewal can be implemented.",
      "createdAt": "2025-03-14T08:40:21Z",
      "updatedAt": "2025-03-14T08:40:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOODoKls6uBiHC",
      "title": "No token at connection but token for actions",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/2",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "One of the limitations of having a unique global token to rule all future actions is that the token's expiration time must be long to anticipate the actions in the future. It can be preferrable to have tokens with short expiration time for specific action, but it contradicts the global unique token.\n\nI would like to define an alternative workflow, where the token at WebTransport is optional, but a token must be carried in the actions (SUBSCRIBE, FETCH, ...) as authentication-parameter.",
      "createdAt": "2025-03-14T08:59:41Z",
      "updatedAt": "2025-07-12T22:18:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "Some ideas on how to achieve this:\n1. You give the player two tokens - one for the connection and another for actions. \n2. In the moqt claim, we add an action for \"CONNECT\". We then rely on future implementation of composite claims so that each  moqt action can be combined with an existing CAT claim such as time, geo etc. ",
          "createdAt": "2025-03-14T09:15:37Z",
          "updatedAt": "2025-03-14T09:15:37Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "This use case is address by https://datatracker.ietf.org/doc/draft-lemmons-composite-claims/",
          "createdAt": "2025-07-12T22:18:17Z",
          "updatedAt": "2025-07-12T22:18:17Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOODoKls6uEJaW",
      "title": "does the expiration of a token also apply to the ongoing SUBSCRIBE?",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/3",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Let's say an end-user connects to a Relay with a token that expires in 60 minutes. What I understand is that, if the user emits a SUBSCRIBE 65 minutes later, then the Relay will reject the request. However, if the user sends a SUBSCRIBE to a track immediately after the connection, it got the stream. 60 minutes later, should the Relay abruptly stop the track delivery? It would require the Relay to keep trace of the finishing time of each ongoing track. ",
      "createdAt": "2025-03-14T14:02:01Z",
      "updatedAt": "2025-03-18T13:50:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "As currently defined, the expiry time applies only to the initial connection. This means that if the client connects  to the relay with a 60min token at 10:00, then the client can do all the subscribing that it wants, but at 11:00, the relay will terminate the connection, which will effectively end all tracks being published and or subscribed in that session. ",
          "createdAt": "2025-03-18T13:50:51Z",
          "updatedAt": "2025-03-18T13:50:51Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOODoKls6uFN6-",
      "title": "token revocation",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/4",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It can happen that the content distributor would like to revoke a token. It is an offline action, which can impact the ongoing sessions.\n\nIf the full token is revoked, then it should mean closure of the WebTransport or MoQ connection. This can happen when the content distributor has identified the end-user as a leak.\n\nIf only some MoQT actions are revoked, then the related actions should be stopped: for example the Relay should stop the subscription to a track whose grant has been revoked. The use cases are less clear, but, I can think of a countermeasure where an identified leak can no longer get the top video profile but can still access a subset of degraded tracks.",
      "createdAt": "2025-03-14T15:49:20Z",
      "updatedAt": "2025-07-14T17:21:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Check to see if the moqt-reval claim helps: https://github.com/wilaw/CAT-4-MOQT/blob/main/draft-law-moq-cat4moqt.md#moqt-reval-claim \n\nThe idea here is that relays will keep the token associated with the stream and simply schedule re-evaluation at a future time. When you get a revocation, you add it to the bad list and then the next time you reval the token, it will fail and you'll terminate the stream.",
          "createdAt": "2025-07-14T17:21:28Z",
          "updatedAt": "2025-07-14T17:21:28Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOODoKls6uY6_m",
      "title": "Add a new CONNECTION action to the moq claim",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/5",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Right now, we assume the existing CAT claims (exp, catu, geohash etc) apply to the initial connection via either Web transport or native QUIC.\n\nThis relationship becomes brittle if we introduce COMPOSITE claims, in which there may be multiple 'exp' claims bound to Actions, while some remain unbound and are assumed to apply to the connection.\n\nAn improvement here would be to make 2 changes\n1. Add in CONNECTION as a new ACTION type.\n2. Allow claims to be composite. \n\nFor example the following combination lets you connect from anywhere before a certain time,  but only publish from Germany with a prefix match of example.com\n\nMOQ CONNECTION allowed AND exp  = 1742229697 \nMOQ PUBLISH (prefix match 'example.com') AND catgeoiso3166 = DE",
      "createdAt": "2025-03-17T16:47:05Z",
      "updatedAt": "2025-03-18T13:23:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "One problem I discovered with this approach is that you cannot repeat a claim in a CWT token. So you cannot have two expiry or geo claims, one for connect, another for publish. ",
          "createdAt": "2025-03-18T13:23:32Z",
          "updatedAt": "2025-03-18T13:23:32Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOODoKls6vEm70",
      "title": "Add TRACK_STATUS_REQUEST action",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/6",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/moq-wg/moq-transport/issues/720\n\nAlternately it could share SUBSCRIBE, or we could have a blanket action like CONSUME which would cover SUBSCRIBE, FETCH and TRACK_STATUS_REQUEST.",
      "createdAt": "2025-03-21T04:20:12Z",
      "updatedAt": "2025-03-21T23:56:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "Adding a TRACk_STATUS_REQUEST action is an easy move.\n\nI really like the idea of CONSUME. It is a logical aggregation which is likely to be highly common and it reduces the need to define a moqt claim for each child action. We should add SUBSCRIBE_ANNOUNCES to that pool. \n\nShould we have a counterpoint PRODUCE, which would aggregate ANNOUNCE and PUBLISH? ",
          "createdAt": "2025-03-21T10:04:34Z",
          "updatedAt": "2025-03-21T10:04:34Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Maybe three actions: PRODUCE (Publish, Announce), CONSUME (Track Status Request, Subscribe, Fetch), DISCOVER (Subscribe Announces)?",
          "createdAt": "2025-03-21T23:56:44Z",
          "updatedAt": "2025-03-21T23:56:44Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOODoKls6vyvuO",
      "title": "When are claims evaluated in long duration sessions?",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/7",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "CAT claims are written assuming a request, which occurs at a single point in time. However MOQT has actions which can persist over the life of the session, which may last a long time. This issue raises the need to evaluate the claims within CAT and define how they might be applied to long running sessions. \n\nFor example, if a claim binds a connection to an IP address and that IP address later changes while the session is still active due to QUIC connection migration, should the connection be dropped? \n\nAt what interval is the server required to evaluate the IP address - with each incoming QUIC frame, or MOQT object or some other interval or event? ",
      "createdAt": "2025-03-26T11:54:34Z",
      "updatedAt": "2025-03-26T11:54:34Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOODoKls6zTjzr",
      "title": "A wrapper for composite claims",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/8",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "How do we bind ACTIONs to differentiated base CAT claims? For example , you can connect and SUBSCRIBE from anywhere in Europe after 4pm  but you can only PUBLISH after 6pm in Germany?\n\nOne solution would be to define a wrapper to hold different CAT tokens and allow them to be assigned to different ACTIONS. \nThe wrapper needs to be signed to be prevent tampering, but not encrypted, since the core CAT tokens it includes are already encrypted. \n\n![Image](https://github.com/user-attachments/assets/284afdbd-c4e7-4eda-bf45-e2c9f068bf68)\n",
      "createdAt": "2025-04-21T11:48:21Z",
      "updatedAt": "2025-07-12T22:17:42Z",
      "closedAt": "2025-07-12T22:17:42Z",
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "Composite claims are now addressed by https://datatracker.ietf.org/doc/draft-lemmons-composite-claims/.",
          "createdAt": "2025-07-12T22:17:42Z",
          "updatedAt": "2025-07-12T22:17:42Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOODoKls61j04J",
      "title": "Explain how DPOP will work and add field to MOQT if required.",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/11",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There is a commercial desire to ensure that Demonstrating Proof of Possession (DPOP) can work with CAT-4-MOQT. \n\nThere should be a section in the draft outlining what claims should be used, the data they should carry and how the proof is communicated to the server. \n\nIf a new MOQT field is required to transmit the proof, then a clear request should be made to https://github.com/moq-wg/moq-transport/issues/968\n",
      "createdAt": "2025-05-07T13:56:26Z",
      "updatedAt": "2025-07-14T16:56:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I _think_ that the existing DPOP-supporting claims in CAT will work, but MOQ will need a way to communicate the POP. HTTP provides the POP in a header, so MOQ will need a control message that can include a POP.",
          "createdAt": "2025-07-14T16:56:08Z",
          "updatedAt": "2025-07-14T16:56:08Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOODoKls63x2QT",
      "title": "Revocation may require a lot of processing at Relay(s)",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/12",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When a service provider wants to revoke a user, the revocation system should update the denylist of all Relays. Typically adding a token ID (e.g., cti) to a local database. Yet, in moQ, a Relay is expected to maintain a list of \"validated tokens\" associated with some established connections (WebTransports) and to continue streaming to these connections, until revalidation of the token.\n\nAt the reception of an update in the denylist, the Relay should parse all existing validated tokens to check whether it should be denied. It may be a significant processing task.\n\nNot sure how to fix it.\n\nOne option would be for the token issuer to indicate, in the token, the claim that is expected to be used for denial (it may be cti, but also some other claims), so that the Relay may store all validated token in a HashTable with the said claim in key.",
      "createdAt": "2025-05-22T12:58:16Z",
      "updatedAt": "2025-05-23T12:19:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "body": "I think we should indicate that if you intend to revoke tokens, you MUST include a cti claim. The relay can then store the CTI against that session and easily match it against a denylist update.\n\n> At the reception of an update in the denylist, the Relay should parse all existing validated tokens to check whether it should be denied. It may be a significant processing task.\n\nThe relay does not have to re-parse tokens it has already parsed. It parses them once upon receipt and stores the CTI as metadata against that session. ",
          "createdAt": "2025-05-23T12:19:21Z",
          "updatedAt": "2025-05-23T12:19:21Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOODoKls64lAnR",
      "title": "Add CLIENT-SETUP as a protected action.",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/13",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Per https://github.com/moq-wg/moq-transport/pull/1013#, there is a likelihood that we need to add the CLIENT-SETUP message to our list of protected MOQT actions. ",
      "createdAt": "2025-05-28T09:36:51Z",
      "updatedAt": "2025-05-28T09:36:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOODoKls7ARUj-",
      "title": "Binary match required instead of text match.",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/14",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "CTA-5007-B 4.6.1, as referenced in the [moqt claim](https://wilaw.github.io/CAT-4-MOQT/draft-law-moq-cat4moqt.html#name-moqt-claim), defines matching for text strings. We need a binary match definition for namespace and name. ",
      "createdAt": "2025-07-12T20:57:20Z",
      "updatedAt": "2025-07-14T16:42:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Double-check the merged text. This is one that I updated after our conversation. The current text handles the binary match definition. Whether people like it or not is a totally different question, but it's defined. :)",
          "createdAt": "2025-07-14T16:42:27Z",
          "updatedAt": "2025-07-14T16:42:27Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOODoKls7ARp3G",
      "title": "What type of matches do we really need?",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/16",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current draft proposes match types of \n\nPrefix - match from start\nExact - exact match\nSuffix - match from end\nMatches  - mid-content match. \n\nComments have been made that MOQT specifies only prefix matching for NAMEPACES and NAMES and therefore that this is all we need on the auth side too.\n\nHowever a counter argument is that we need more flexibility when specifying constraints than we do when matching namespaces. \n\nMy recommendation would be to \n1. Keep PREFIX and EXACT  - these are well aligned with MOQT semantics \n2. Drop SUFFIX and MATCH as I can't see a use case for these",
      "createdAt": "2025-07-12T22:24:25Z",
      "updatedAt": "2025-07-14T17:16:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One typical use for \"SUFFIX\" is when extensions or names are used to provide information about the resource. For example, in HTTP, you can often say something like:\n\n```\n{\n    /catu/ 312: { /path/ 3: { /prefix/ 1: \"/path/to/folder/\" } },\n    /or/ TBD_OR: [\n        { /catu/ 312: { /path/ 3: { /suffix/ 2: \"/manifest.m3u8\" } } },\n        { /catu/ 312: { /path/ 3: { /suffix/ 2: \".ts\" } } }\n   ]\n}\n```\n\nIn HTTP, the prefix usually represents some kind of \"category\" for the content and the suffix tends to have information about the \"kind\" of the content, with stuff like extension or file name. None of these are hard-and-fast rules, but because people usually structure things that way make both prefix and suffix useful.\n\nMATCH does mostly exist for completeness, though. It would be pretty easy to drop. (Though it's also easy to perform, cause it's doable with a simple scan.)",
          "createdAt": "2025-07-14T17:16:08Z",
          "updatedAt": "2025-07-14T17:16:08Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOODoKls7BVIbq",
      "title": "Definition of catif for MoQ actions",
      "url": "https://github.com/wilaw/CAT-4-MOQT/issues/18",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Related to https://github.com/wilaw/CAT-4-MOQT/pull/9/files#r2095934066\n\nToday's catif sections in CAT is \"_The type of this claim is a map; the keys of the map are either claim keys or arrays of claim keys and the values are arrays; the arrays have up to three elements: the status code to return, a map with headers and values (the header map), and a TextString that identifies a key to sign the resultant URI with (the key id)_\"\n\nA moqt-reval-label can typically be used as the key, but the response would ideally be a MoQ message. For example, if an ongoing Suscription is stopped, the Publisher should send a SUBSCRIBE_ERROR with code 0x1, while an ongoing fetch would require a FETCH_ERROR.     ",
      "createdAt": "2025-07-18T15:09:04Z",
      "updatedAt": "2025-07-18T15:09:04Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOODoKls6UzS5E",
      "title": "First round of edits to fill out the definition of the claim.",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/9",
      "state": "MERGED",
      "author": "alficles",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-02T22:30:52Z",
      "updatedAt": "2025-07-12T20:30:11Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "8687628347be73234f01fdf16e06ff5bcbadce70",
      "headRepository": "alficles/CAT-4-MOQT",
      "headRefName": "main",
      "headRefOid": "1399b1d0eb685327bf15727d77de938d6bd26e58",
      "closedAt": "2025-07-12T20:30:11Z",
      "mergedAt": "2025-07-12T20:30:11Z",
      "mergedBy": "wilaw",
      "mergeCommit": {
        "oid": "fd8dff1ad0609a28ac6a6fb5b3f402aebaec60cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOODoKls6nrit7",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "This is a great start Chris - thanks for kicking it off. ",
          "createdAt": "2025-05-03T10:51:09Z",
          "updatedAt": "2025-05-03T11:27:21Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "The actions in MOQT are not extensible and are not defined in a registry,. They are defined by a particular version of the specification .  I think we can avoid the registry table and instead indicate that if anyone extends this specification to match a future version of MOQT, that they should provide a new action and its key.  \r\n\r\nThe actions we need to support with the current draft of MOQT are\r\n\r\nCONNECT\r\nANNOUNCE\r\nSUBSCRIBE_ANNOUNCES\r\nSUBSCRIBE\r\nFETCH\r\nPUBLISH (not yet defined but likely will be). \r\nTRACK_STATUS_REQUEST\r\n",
              "createdAt": "2025-05-03T10:51:09Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 91,
              "body": "For simplicity we should exclude SHA* match types and just allow exact-match, prefix-match, suffix-match and contains-match. ",
              "createdAt": "2025-05-03T10:53:13Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 96,
              "body": "Namespace is always a byte array, as is Name.  Even though URLs are used for clarity in most examples, in practice a streaming format would need to specify how these are serialized i.e UTF-8. ",
              "createdAt": "2025-05-03T10:55:46Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 107,
              "body": "This needs to be a byte match, not a string match. ",
              "createdAt": "2025-05-03T10:56:23Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 108,
              "body": "Name should also be a byte match",
              "createdAt": "2025-05-03T10:56:53Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 93,
              "body": "in MOQT a Track Namespace is an ordered N-tuple of bytes where N can be between 1 and 32. Track Name is a sequence of bytes that identifies an individual track within the namespace.\r\nSee https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#name-track-naming\r\n\r\nFor the token, I don't think we need to specify a N-32 tuple for the match. We can indicate that the tuples should be concatenated and then compared. Language might be `Namespaces are compared using lexicographic ordering on their byte-wise representations, where each namespace is treated as a byte string formed by concatenating its constituent bytes in order.\r\n`",
              "createdAt": "2025-05-03T11:09:45Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 198,
              "body": "Yes, this is an important point. I will raise for discussion at Stockholm interim. Some ideas\r\n1. We leave the interval up to the enforcer. Some might find it cheap to evaluate with each object sent, others at a time interval. This will lead to poor interop so I don't like this approach. \r\n2. We can set upper bounds on the maximum time at which each claim MUST be checked. This may be per object sent, 1s wallclock time, 10s, 60s etc. This may be set by this RFC, or it may be a part of the claim payload?",
              "createdAt": "2025-05-03T11:17:34Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 229,
              "body": "As mentioned earlier, actions are defined by MOQT RFC and are not extensible. We can require that new specifications include and action and a key value when extending cat-4-moqt. \r\n\r\nReusing message id is not an option. The message id mutates with each message sent so it would not work for the repeated use of tokens. \r\n> The client's Request ID starts at 0 and are even and the server's Request ID starts at 1 and are odd. The Request ID increments by 2 with ANNOUNCE, FETCH, SUBSCRIBE, SUBSCRIBE_ANNOUNCES or TRACK_STATUS request.",
              "createdAt": "2025-05-03T11:22:54Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            },
            {
              "originalPosition": 181,
              "body": "Would be nice to add an additional example showing a complete set of composite claims, using expiry, not before, cwt ID, geo, etc. ",
              "createdAt": "2025-05-03T11:26:44Z",
              "updatedAt": "2025-05-03T11:27:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nvIH2",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T08:36:19Z",
          "updatedAt": "2025-05-05T08:36:19Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Should we consider contains-match? It could be heavy in terms of processing at the edge. We may also need to explain how to compute this match based on the N (1..32) set of bytes. For example, do we allow */foo/*/bar/*?\r\n\r\nSimilarly, is there a use-case for suffix-match? \r\n\r\nIn MOQT, the announces are based on Prefix only, aren't they?   ",
              "createdAt": "2025-05-05T08:36:19Z",
              "updatedAt": "2025-05-05T08:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nvIdz",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T08:37:00Z",
          "updatedAt": "2025-05-05T08:37:00Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Same as previous comment. \r\nWe could restrict the operation to the Prefix-match, which is the one defined in MOQT.",
              "createdAt": "2025-05-05T08:37:00Z",
              "updatedAt": "2025-05-05T08:37:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nwIev",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T10:37:46Z",
          "updatedAt": "2025-05-05T10:37:47Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "We have a bigger problem in that I believe the match functions operate on strings only, not on byte arrays",
              "createdAt": "2025-05-05T10:37:46Z",
              "updatedAt": "2025-05-05T10:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nyVmt",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T14:19:33Z",
          "updatedAt": "2025-05-05T14:19:33Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "The need for re-evaluation is indeed a point (also related to #3 and #7).\r\n\r\nYour idea 1 does not bring any guarantee of content protection, which is indeed not ideal.\r\nYour idea 2 may potentially be exploited. A pirates who knows when the server will check the IP address to verify some claims can migrate IP only for one object and continue streaming the rest of the time.\r\n\r\nA third idea would be to verify the claims when one of the characteristics related to the claims changes mid-stream. For example a HTTP/3 hook when the IP address changes at QUIC level would force a re-validation of the claims related to catnip and geo claims. The server would need to store, for every connection, all the characteristics that have been used to validate the claim at the latest verification. The advantage is that, for a stable connection, the server would never re-process the token,",
              "createdAt": "2025-05-05T14:19:33Z",
              "updatedAt": "2025-05-05T14:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzLOb",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:29:13Z",
          "updatedAt": "2025-05-05T15:29:13Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "There's not a ton of point excluding the SHA options because making them optional for the receiver (that is, not a point on which you can guarantee interoperability) already effectively does it. For contains, the maximum cost is a single scan of the string, which is guaranteed to be relatively short.",
              "createdAt": "2025-05-05T15:29:13Z",
              "updatedAt": "2025-05-05T15:29:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzO6X",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:35:06Z",
          "updatedAt": "2025-05-05T15:35:06Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "As I noodle on this, I'm thinking that we might handle token evaluation the same way you handle caching. The token could tell you how long you're allowed to cache the results and if you ask the relay to revalidate more frequently than it is willing, it stops serving your content. In practice, implementers would pick a minimum and reject tokens that ask for too frequent revalidation.\r\n\r\nConsidering that in the ABR world, people can and do re-evaluate the token, including the signature (which doesn't need re-checking for MOQT), every single fragment, I suspect that even extremely frequent re-evaluation isn't going to break anything.",
              "createdAt": "2025-05-05T15:35:06Z",
              "updatedAt": "2025-05-05T15:35:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzU7Z",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:43:27Z",
          "updatedAt": "2025-05-05T15:43:27Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I should have said Message Type IDs here. See Figure 3 in Section 8 of draft-ietf-moq-transport. So, for example, ANNOUNCE is 0x6, FETCH is 0x16, SUBSCRIBE is 0x3, SUBSCRIBE_ANNOUNCES is 0x11, and TRACK_STATUS is 0xE. The advantage is that you don't wind up using different numbers to describe the same concept and it means you don't have to define a list in the auth token. It also makes it effectively automatically extensible if someone defines a new frame in the future.\r\n\r\nThe main downside is that it allows you to express the idea of having the auth token apply to message types that might not make sense, like \"FETCH_ERROR\" or \"MAX_REQUEST_ID\". This could lead to confusion, or in the worst case, a naive implementation causing real problems for themselves.",
              "createdAt": "2025-05-05T15:43:27Z",
              "updatedAt": "2025-05-05T15:43:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6nzZiM",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T15:50:55Z",
          "updatedAt": "2025-05-05T15:50:55Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I think I'm going to have to re-define the match object, though, which is mildly annoying. I'd be fine if I had defined the input to match in CAT as a byte array, but alas, this is the kind of minor incompatibility I was worried about. The devil is always in the details. :)\r\n\r\nThere genuinely is a difference here, because the byte array is allowed to contain invalid unicode characters. And if someone implemented this with a library that handles unicode, concatenating a namespace with invalid unicode with a track name that you incorrectly assume is unicode can result in misinterpreting the first byte, which in the context of an auth token can result in incorrect access.",
              "createdAt": "2025-05-05T15:50:55Z",
              "updatedAt": "2025-05-05T15:50:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6n1mZw",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-05T19:20:06Z",
          "updatedAt": "2025-05-05T19:20:07Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I like idea of reusing the message type as its naturally extensible without having to rev this draft.  There is no danger in having the token apply to message types that don't carry auth precisely because the serialization of those message types doesn't provide for transmission of the auth token. \r\n\r\nOne problem is that if we want to protect CONNECT, it is not a message. We could use the special type of 0x0 for this, but now we have a blend of custom defined types and MOQT message types. \r\n\r\nAnother problem is that MOQT might reassign message types between versions? ",
              "createdAt": "2025-05-05T19:20:06Z",
              "updatedAt": "2025-05-05T19:25:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6oGQ49",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T03:21:25Z",
          "updatedAt": "2025-05-07T03:21:25Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "wonder if we can make moq actions just an array with the base case being array of single element",
              "createdAt": "2025-05-07T03:21:25Z",
              "updatedAt": "2025-05-07T03:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6oGR04",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T03:24:33Z",
          "updatedAt": "2025-05-07T03:24:33Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "may be we should limit the match possibilities to exact and prefix match. Also a CAT question, can't prefix match also perform exact match as well ?",
              "createdAt": "2025-05-07T03:24:33Z",
              "updatedAt": "2025-05-07T03:24:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6oGU-a",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T03:28:04Z",
          "updatedAt": "2025-05-07T03:28:04Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Agree with @wilaw. Does we need a new match operation ?",
              "createdAt": "2025-05-07T03:28:04Z",
              "updatedAt": "2025-05-07T03:28:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6oGWTf",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T03:31:01Z",
          "updatedAt": "2025-05-07T03:31:02Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "just an observation, can we call it \"scope\" or \"authz-scope\" or \"authz-cover\" instead of limit. ",
              "createdAt": "2025-05-07T03:31:02Z",
              "updatedAt": "2025-05-07T03:31:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pu1wd",
          "commit": {
            "abbreviatedOid": "96281e1"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T21:09:45Z",
          "updatedAt": "2025-05-16T21:26:30Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Not sure I understand the question. A prefix match on \"/bob\" matches \"/bob\", \"/bobby\", \"/bob/stuff\". An exact match would only match the first.",
              "createdAt": "2025-05-16T21:09:45Z",
              "updatedAt": "2025-05-16T21:26:30Z"
            },
            {
              "originalPosition": 181,
              "body": "Yeah, once we're happy with the claim itself, a couple of fulsome examples are definitely in order.",
              "createdAt": "2025-05-16T21:16:24Z",
              "updatedAt": "2025-05-16T21:26:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pu7Gm",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T21:27:13Z",
          "updatedAt": "2025-05-16T21:27:14Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I redefined this to work for binary strings.",
              "createdAt": "2025-05-16T21:27:14Z",
              "updatedAt": "2025-05-16T21:27:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pu7bt",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T21:28:22Z",
          "updatedAt": "2025-05-16T21:28:22Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I left this comment in, because it might be easy for someone to assume that the URI-looking things should be treated that way. I could reword it, though.",
              "createdAt": "2025-05-16T21:28:22Z",
              "updatedAt": "2025-05-16T21:28:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pu8n_",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T21:32:44Z",
          "updatedAt": "2025-05-16T21:32:45Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "The CONNECT example convinced me that we should just enumerate the correct values here.",
              "createdAt": "2025-05-16T21:32:44Z",
              "updatedAt": "2025-05-16T21:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pvLBS",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T22:26:34Z",
          "updatedAt": "2025-05-16T22:26:34Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Ok, check out below. I have a suggestion for a revalidation scheme. This might be simpler than the \"expires\" suggestion from https://github.com/moq-wg/moq-transport/pull/1012 , but it is specific to this token. Other tokens would then necessarily have to include their own revalidation scheme, which might be simpler or more complex than this one.",
              "createdAt": "2025-05-16T22:26:34Z",
              "updatedAt": "2025-05-16T22:26:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6pvLtV",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-16T22:29:32Z",
          "updatedAt": "2025-05-16T22:29:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Making a note here that I did not switch to a concatenated version. Unless ['example.com', 'bob'] is supposed to be semantically interchangeable with ['example.co', 'mbob'], I don't think we can safely concat them.",
              "createdAt": "2025-05-16T22:29:32Z",
              "updatedAt": "2025-05-16T22:29:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6p3nCj",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T08:42:47Z",
          "updatedAt": "2025-05-19T08:42:47Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Thanks for the idea. I like it. Though, we need to disambiguate\r\n- **revalidation time**: as you suggested, it would be smart to have a claim that instructs the Relay when it should revalidate the token claims. We don't have such a claim in CAT. Should it be in the token, or should it be carried by another mean so that the Relay can read it?\r\n- **expiration time**: we already have an optional claim in CAT. The need to renew token in MoQ is debatable. Since we have an established Client/Server connection, CDN leeching based on token reuse can be handled (replay is harder). \r\n\r\nIf I understands, the \"expires\" parameter aims at notifying the client that it must renew the token, just for the sake of revalidating it. I believe it is unnecessary. Revalidation is an internal (Relay-only) operation, which does not require client (nor control-plane) intervention. I am not comfortable with this \"expires\" parameter in MoQ. ",
              "createdAt": "2025-05-19T08:42:47Z",
              "updatedAt": "2025-05-19T08:42:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6p8KjX",
          "commit": {
            "abbreviatedOid": "60550df"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T15:09:31Z",
          "updatedAt": "2025-05-19T15:09:31Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "I added a new claim for revalidation called moqt-reval in this updated PR. Check out how it works and let me know what you think. It adds the claim directly into the CAT, in the base claimset where it can be reliably located. Expiration is handled the way it always is.\r\n\r\nAnd yeah, the fact that the expires claim requires resubmission of the token feels wrong. We could move the \"mandatory revalidation time\" into the parameters for the request, like \"expires\", but then a token that needed a different revalidation strategy wouldn't be able to implement it differently.\r\n\r\nIt's worth noting that we'll have to do a touch of work to make catr or catif work with MOQ, because both of those are defined in terms of HTTP. Doable, but not automatic.",
              "createdAt": "2025-05-19T15:09:31Z",
              "updatedAt": "2025-05-19T15:09:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6p8gpG",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T15:29:49Z",
          "updatedAt": "2025-05-19T15:29:49Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "It is overall excellent. Though, \"frequency expressed in seconds\" seems wrong to me (I am used to period in seconds and frequency in hertz). Maybe another word than frequency should be used? ",
              "createdAt": "2025-05-19T15:29:49Z",
              "updatedAt": "2025-05-19T15:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6p9GOv",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T16:18:35Z",
          "updatedAt": "2025-05-19T16:18:36Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "I think we noun we want is \"interval\". ",
              "createdAt": "2025-05-19T16:18:35Z",
              "updatedAt": "2025-05-19T16:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6p95s-",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "alficles",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-19T17:42:46Z",
          "updatedAt": "2025-05-19T17:42:46Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Yup. Interval is correct here. I'll fix.",
              "createdAt": "2025-05-19T17:42:46Z",
              "updatedAt": "2025-05-19T17:42:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6qiCLa",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T12:32:55Z",
          "updatedAt": "2025-05-22T12:32:55Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Should we consider having actions in **catif** for a failed moqt-reval?\r\n\r\nMore generally, what should we do if the action is not permitted to continue?  ",
              "createdAt": "2025-05-22T12:32:55Z",
              "updatedAt": "2025-05-22T12:32:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6qiDUP",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T12:34:26Z",
          "updatedAt": "2025-05-22T12:34:27Z",
          "comments": [
            {
              "originalPosition": 267,
              "body": "If the token includes an expiration, the cat-reval should be at least the delay until the expiration time. Should we write something in this regard?",
              "createdAt": "2025-05-22T12:34:26Z",
              "updatedAt": "2025-05-22T12:34:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOODoKls6qj3-x",
          "commit": {
            "abbreviatedOid": "1399b1d"
          },
          "author": "gwendalsimon",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-22T14:43:13Z",
          "updatedAt": "2025-05-22T14:43:13Z",
          "comments": [
            {
              "originalPosition": 267,
              "body": "More generally, the exp and the cat-reval should be disjoint  In that case, the exp will trigger a revalidation, regardless of the cat-reval value. So, an exp at a given time and a cat-reval 0 or a cat-reval that would trigger a revalidation _after_ the exp would not matter. It would also cover the cases where the token includes an exp but no cat-reval.",
              "createdAt": "2025-05-22T14:43:13Z",
              "updatedAt": "2025-05-22T14:43:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOODoKls6U6F0O",
      "title": "Update draft-law-moq-cat4moqt.md",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/10",
      "state": "MERGED",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Polishing the Introduction to refine the concept of \"trusted MoQ distribution network\"",
      "createdAt": "2025-05-05T09:27:42Z",
      "updatedAt": "2025-05-21T09:57:49Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "8687628347be73234f01fdf16e06ff5bcbadce70",
      "headRepository": "gwendalsimon/CAT-4-MOQT",
      "headRefName": "patch-1",
      "headRefOid": "961ee58c8ad7e77acdcf8ce0d0b4afc74c276fe4",
      "closedAt": "2025-05-21T09:57:49Z",
      "mergedAt": "2025-05-21T09:57:49Z",
      "mergedBy": "wilaw",
      "mergeCommit": {
        "oid": "53abf752984c235e9a05837ab21e5df4fad446c7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOODoKls6qS3Rg",
          "commit": {
            "abbreviatedOid": "c241235"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2025-05-21T09:54:25Z",
          "updatedAt": "2025-05-21T09:54:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOODoKls6qS46l",
          "commit": {
            "abbreviatedOid": "c241235"
          },
          "author": "wilaw",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-21T09:56:24Z",
          "updatedAt": "2025-05-21T09:56:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  to validate signatures.\r\n```",
              "createdAt": "2025-05-21T09:56:24Z",
              "updatedAt": "2025-05-21T09:56:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOODoKls6epjI7",
      "title": "Updating action table and examples",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/15",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #13\r\nFixes #6 \r\nFixes #5 ",
      "createdAt": "2025-07-12T21:38:45Z",
      "updatedAt": "2025-07-12T21:38:45Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "fd8dff1ad0609a28ac6a6fb5b3f402aebaec60cd",
      "headRepository": "wilaw/CAT-4-MOQT",
      "headRefName": "wilaw-patch-1",
      "headRefOid": "abe2d465f1a9a0a078e0a75472ace6037e4a33db",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOODoKls6flq2S",
      "title": "\"Interval\" instead of \"frequency\" in the revalidation section",
      "url": "https://github.com/wilaw/CAT-4-MOQT/pull/17",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Related to https://github.com/wilaw/CAT-4-MOQT/pull/9#discussion_r2096221009",
      "createdAt": "2025-07-18T14:41:01Z",
      "updatedAt": "2025-07-18T14:41:02Z",
      "baseRepository": "wilaw/CAT-4-MOQT",
      "baseRefName": "main",
      "baseRefOid": "fd8dff1ad0609a28ac6a6fb5b3f402aebaec60cd",
      "headRepository": "gwendalsimon/CAT-4-MOQT",
      "headRefName": "patch-2",
      "headRefOid": "5cc3fe7d1ce318c73ae6227c9971a9cce377ef47",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}